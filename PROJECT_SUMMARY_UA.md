# CRM External Service - Підсумок проекту

> **Тип:** Зовнішній сервіс (Standalone NestJS Application)  
> **Призначення:** Зовнішній сервіс з інтеграцією SSO для CRM системи  
> **Технологічний стек:** NestJS, TypeScript, Passport JWT (RS256), Axios

## Огляд

Це standalone NestJS додаток, який виконує роль зовнішнього сервісу, інтегрованого з основною CRM системою через SSO (Single Sign-On) автентифікацію. Сервіс дозволяє користувачам автентифікуватися один раз на основному сервері та безперешкодно отримувати доступ до зовнішніх сервісів.

## Архітектура

### Тип проекту
- **Standalone NestJS Application** (окремо від основної CRM)
- **Мікросервісна** архітектура
- **Без стану (stateless)** - використовує JWT service токени для автентифікації
- **Без бази даних** - спілкується з основним CRM сервером через HTTP API

### Технологічний стек

**Основна платформа:**
- NestJS 11.x
- TypeScript 5.x
- Express (через @nestjs/platform-express)

**Автентифікація та безпека:**
- Passport.js з JWT стратегією
- RS256 (RSA) алгоритм для валідації JWT
- Публічний ключ отримується з основного сервера або налаштовується через env

**HTTP клієнт:**
- Axios (через @nestjs/axios)
- Для комунікації з основним CRM сервером

**Документація:**
- Swagger/OpenAPI (через @nestjs/swagger)
- Доступна за адресою `/api/docs`

**Конфігурація:**
- @nestjs/config для змінних оточення
- Глобальний ConfigModule

**Валідація:**
- class-validator
- class-transformer
- Глобальний ValidationPipe

## Структура проекту

```
crm_external_service/
├── src/
│   ├── main.ts                    # Точка входу додатку
│   ├── app.module.ts              # Кореневий модуль
│   │
│   ├── auth/                      # Модуль автентифікації
│   │   ├── auth.service.ts        # Логіка SSO потоку
│   │   ├── auth.guard.ts          # JWT guard для автентифікації
│   │   ├── jwt.strategy.ts        # Passport JWT стратегія (RS256)
│   │   └── interfaces/
│   │       └── request-with-token.interface.ts
│   │
│   ├── config/                    # Конфігурація
│   │   ├── config.module.ts       # Модуль конфігурації
│   │   └── jwt.config.ts          # JWT конфігураційний сервіс (управління публічним ключем)
│   │
│   ├── controllers/               # API контролери
│   │   ├── auth.controller.ts     # SSO endpoints
│   │   ├── health.controller.ts   # Перевірки здоров'я
│   │   └── operations.controller.ts # Бізнес-операції (захищені)
│   │
│   ├── services/                  # Сервіси бізнес-логіки
│   │   ├── main-server-client.service.ts # HTTP клієнт для основної CRM
│   │   ├── balance-api.service.ts # Обгортка для операцій з балансом
│   │   ├── analytics.service.ts   # Обгортка для аналітики
│   │   └── public-key.service.ts  # Отримання/кешування публічного ключа
│   │
│   ├── dto/                       # Data Transfer Objects
│   │   ├── sso-exchange.dto.ts    # Обмін SSO коду
│   │   ├── charge-balance.dto.ts  # Операції з балансом
│   │   └── analytics-event.dto.ts # Аналітичні події
│   │
│   └── filters/                   # Фільтри винятків
│       └── http-exception.filter.ts # Глобальний обробник винятків
│
├── package.json
├── tsconfig.json
├── nest-cli.json
└── README.md
```

## Ключові компоненти

### 1. Автентифікація (`auth/`)

**AuthService:**
- `initiateLogin()` - Повертає SSO URL (редирект на **фронтенд**, не бекенд)
- `handleCallback()` - Обмінює SSO код на service токен (бекенд-до-бекенд)
- `checkAuth()` - Валідує поточний service токен
- `setServiceToken()` / `clearToken()` - Управління токенами

**JwtStrategy:**
- Валідує JWT токени використовуючи RS256 алгоритм
- Валідує тип токена як `service`
- Опціональна валідація імені сервісу
- Публічний ключ з `JwtConfigService`

**JwtAuthGuard:**
- Захищає роути, що потребують автентифікації
- Валідує тип service токена
- Викидає 401 якщо токен невалідний/відсутній

### 2. Конфігурація (`config/`)

**JwtConfigService:**
- Управляє завантаженням та кешуванням JWT публічного ключа
- Попередньо завантажує публічний ключ при ініціалізації модуля
- Підтримує змінну оточення або отримання з основного сервера
- Singleton паттерн для кешування ключа

**PublicKeyService:**
- Отримує публічний ключ з основного сервера: `{MAIN_SERVER_URL}/auth/public-key`
- Кешує публічний ключ на 1 годину
- Обробляє помилки отримання

### 3. Контролери (`controllers/`)

**AuthController:**
- `GET /auth/sso/initiate` - Ініціює SSO потік (редирект на фронтенд)
- `POST /auth/sso/exchange` - Обмінює код на service токен
- `GET /auth/check` - Перевіряє статус автентифікації

**HealthController:**
- `GET /health` - Базова перевірка здоров'я
- `GET /health/ready` - Перевірка готовності (валідує зв'язок з основним сервером)

**OperationsController:**
- `GET /operations/profile` - Отримати профіль користувача (захищено)
- `GET /operations/balances` - Отримати баланси користувача (захищено)
- `POST /operations/process-payment` - Обробити платіж (захищено)
- `POST /operations/analytics/event` - Надіслати аналітичну подію (захищено)
- `POST /operations/analytics/batch` - Надіслати пакет аналітичних подій (захищено)

### 4. Сервіси (`services/`)

**MainServerClientService:**
- HTTP клієнт для комунікації з основним CRM сервером
- Управляє зберіганням service токена
- Методи: `getUserProfile()`, `getUserStructure()`, `getUserPermissions()`, тощо
- Автоматичне додавання токена в заголовок Authorization
- Обробка помилок та форматування відповідей

**BalanceApiService:**
- Обгортка навколо операцій з балансом
- Методи: `getUserBalances()`, `chargeBalance()`, `getBalanceSettings()`

**AnalyticsService:**
- Обгортка навколо аналітичних операцій
- Методи: `sendEvent()`, `sendBatchEvents()`

### 5. Обробка винятків (`filters/`)

**HttpExceptionFilter:**
- Глобальний фільтр винятків
- Обробляє 401 помилки - редірект на SSO (URL фронтенду)
- Форматує відповіді помилок консистентно
- Логує помилки

## Змінні оточення

| Змінна | Опис | Обов'язкова | За замовчуванням | Приклад |
|--------|------|-------------|------------------|---------|
| `MAIN_SERVER_URL` | URL API основного CRM сервера | Так | - | `http://localhost:3000/api` |
| `MAIN_FRONTEND_URL` | URL фронтенду основного CRM сервера | Ні | Автоматично з MAIN_SERVER_URL | `http://localhost:3000` |
| `SERVICE_NAME` | Ідентифікатор сервісу | Так | `crm-external-service` | `external-service` |
| `PORT` | Порт сервера | Ні | `3001` | `3001` |
| `NODE_ENV` | Оточення | Ні | `development` | `production` |
| `JWT_PUBLIC_KEY` | RSA публічний ключ (опціонально) | Ні | Автоматично отримується | `-----BEGIN PUBLIC KEY-----...` |
| `LOG_LEVEL` | Рівень логування | Ні | `debug` | `info` |

## Архітектура SSO потоку

### Важливий принцип
**Користувач НЕ повинен бачити URL бекендів. Всі редіректи для користувачів йдуть на фронтенди.**

### Повний SSO потік

1. **Запит користувача:** Користувач робить запит до зовнішнього сервісу (фронтенд)

2. **Перевірка бекенду:** Бекенд зовнішнього сервісу `AuthGuard` перевіряє service токен в заголовку `Authorization`

3. **Якщо токен відсутній/невалідний:**
   - Зовнішній сервіс редіректить користувача на **фронтенд основного сервісу** (не бекенд)
   - URL: `{MAIN_FRONTEND_URL}/sso/initiate?redirect_uri={external_service_url}&service={SERVICE_NAME}`
   - ✅ Користувач бачить URL фронтенду, не бекенду

4. **Фронтенд основного сервісу:**
   - Фронтенд перевіряє статус автентифікації через `/api/auth/sso/initiate-check`
   - Якщо автентифіковано: редірект на зовнішній сервіс з SSO кодом
   - Якщо не автентифіковано: редірект на сторінку логіну основного сервісу

5. **Після логіну:**
   - Фронтенд основного сервісу редіректить на зовнішній сервіс з SSO кодом
   - URL: `{external_service_url}?code={sso_code}`

6. **Обмін коду:**
   - **Бекенд** зовнішнього сервісу обмінює код на service токен
   - Endpoint: `POST {MAIN_SERVER_URL}/auth/sso/exchange` (бекенд-до-бекенд)
   - Отримує service токен (JWT RS256)

7. **Зберігання токена:**
   - Service токен зберігається в `MainServerClientService`
   - Використовується для подальших API запитів до основного сервера

### Ключові моменти
- Редіректи користувачів: **фронтенд → фронтенд** (користувач бачить тільки URL фронтендів)
- Комунікація бекендів: **бекенд → бекенд** (використовуючи service токени)
- Service токен: JWT RS256, тип `service`, термін дії 90 днів
- Валідація токена: Публічний ключ з основного сервера (кешується 1 годину)

## API Endpoints

### Публічні endpoints

**Автентифікація:**
- `GET /auth/sso/initiate` - Ініціювати SSO логін (редирект на фронтенд)
- `POST /auth/sso/exchange` - Обміняти SSO код на service токен
- `GET /auth/check` - Перевірити статус автентифікації

**Здоров'я:**
- `GET /health` - Перевірка здоров'я
- `GET /health/ready` - Перевірка готовності

**Документація:**
- `GET /api/docs` - Swagger документація

### Захищені endpoints (Потребують `Authorization: Bearer <service-token>`)

**Операції користувача:**
- `GET /operations/profile` - Отримати профіль користувача
- `GET /operations/balances` - Отримати баланси користувача
- `POST /operations/process-payment` - Обробити платіж
- `POST /operations/analytics/event` - Надіслати аналітичну подію
- `POST /operations/analytics/batch` - Надіслати пакет аналітичних подій

## Інтеграція з основним сервером

### Доступні endpoints (через MainServerClientService)

**Користувачі:**
- `GET /users/profile`
- `PUT /users/profile`
- `GET /users/structure`
- `GET /users/my-permissions`

**Баланс:**
- `GET /balance`
- `GET /balance/:currency`
- `GET /balance/transactions`
- `POST /balance/charge`
- `GET /balance/settings`
- `PUT /balance/settings`

**Аналітика:**
- `POST /analytics/events`
- `POST /analytics/events/batch`

Всі запити автоматично включають заголовок `Authorization: Bearer <service-token>`.

## Деталі автентифікації

### Service токен
- **Алгоритм:** RS256 (RSA)
- **Тип:** `service` (валідується в JwtStrategy)
- **Термін дії:** 90 днів
- **Payload:**
  ```typescript
  {
    sub: number;        // ID користувача
    email: string;      // Email користувача
    role: string;       // Роль користувача
    type: 'service';    // Тип токена
    service?: string;   // Ім'я сервісу (опціонально)
    iat?: number;       // Видано в
    exp?: number;       // Термін дії
  }
  ```

### Управління публічним ключем
- Отримується з: `{MAIN_SERVER_URL}/auth/public-key`
- Кешується на 1 годину
- Попередньо завантажується при ініціалізації модуля
- Може бути перевизначений через змінну оточення `JWT_PUBLIC_KEY`
- Fallback: Викидає помилку якщо ключ не може бути завантажений

## Формат відповіді

Всі endpoints повертають консистентний формат відповіді:

**Успіх:**
```typescript
{
  status: 200 | 201,
  data?: any,
  message?: string
}
```

**Помилка:**
```typescript
{
  status: 400 | 401 | 404 | 500,
  message: string,
  error?: string
}
```

## Обробка помилок

### 401 Unauthorized
- Глобальний `HttpExceptionFilter` перехоплює 401 помилки
- Для запитів браузера: Редірект на SSO (URL фронтенду)
- Для API запитів: Повертає JSON з SSO URL
- Формат:
  ```json
  {
    "status": 401,
    "message": "Authentication required",
    "error": "Unauthorized",
    "ssoUrl": "{MAIN_FRONTEND_URL}/sso/initiate?redirect_uri=...",
    "redirect": false
  }
  ```

### Інші помилки
- Стандартні HTTP статус коди
- Консистентний формат відповіді помилки
- Логування через NestJS Logger

## Залежності

### Основні залежності
- `@nestjs/common` - Основна функціональність NestJS
- `@nestjs/core` - Ядро NestJS
- `@nestjs/config` - Управління конфігурацією
- `@nestjs/axios` - HTTP клієнт
- `@nestjs/passport` - Автентифікація
- `@nestjs/jwt` - JWT утиліти
- `@nestjs/swagger` - Документація API
- `passport` - Фреймворк автентифікації
- `passport-jwt` - JWT стратегія
- `axios` - HTTP клієнт
- `class-validator` - Валідація
- `class-transformer` - Трансформація
- `rxjs` - Реактивні розширення

### Залежності для розробки
- TypeScript
- Jest (тестування)
- ESLint
- Prettier
- @nestjs/testing

## Файли конфігурації

### `package.json`
- Стандартна структура проекту NestJS
- Скрипти: `build`, `start`, `start:dev`, `start:prod`, `test`, тощо
- Залежності перелічені вище

### `tsconfig.json`
- Конфігурація TypeScript
- Аліаси шляхів (якщо є)

### `nest-cli.json`
- Конфігурація NestJS CLI

## Ключові деталі реалізації

### 1. Логіка SSO редіректу
- `AuthService.initiateLogin()` використовує `MAIN_FRONTEND_URL` (або виводить з `MAIN_SERVER_URL`)
- Редірект на: `{MAIN_FRONTEND_URL}/sso/initiate?redirect_uri=...&service=...`
- Користувач НЕ повинен бачити URL бекендів

### 2. Зберігання токена
- Service токен зберігається в `MainServerClientService` (в пам'яті)
- Не зберігається в базі даних
- Очищується при перезапуску сервісу

### 3. Завантаження публічного ключа
- `JwtConfigService` попередньо завантажує публічний ключ при ініціалізації модуля
- `PublicKeyService` кешує ключ на 1 годину
- Fallback на змінну оточення якщо отримання не вдалося

### 4. Потік запиту
1. Запит надходить до контролера
2. `JwtAuthGuard` валідує токен
3. Якщо валідний: Запит продовжується
4. Якщо невалідний: 401 → `HttpExceptionFilter` → Редірект на SSO (фронтенд)

### 5. Комунікація з основним сервером
- Всі запити до основного сервера використовують `MainServerClientService`
- Автоматичне додавання токена в заголовок `Authorization`
- Консистентна обробка помилок
- Конвертація формату відповіді

## Розгляди для тестування

- Unit тести: Тестувати сервіси незалежно
- Інтеграційні тести: Тестувати з замоканим основним сервером
- E2E тести: Тестувати повний SSO потік
- Mock залежності: `HttpService`, `ConfigService`

## Розгляди для деплою

### Налаштування оточення
- Встановити `MAIN_SERVER_URL` (обов'язково)
- Встановити `MAIN_FRONTEND_URL` (рекомендовано, або автоматично виводиться)
- Встановити `SERVICE_NAME` (обов'язково)
- Опціонально: `JWT_PUBLIC_KEY` (якщо не отримується з основного сервера)

### Перевірки здоров'я
- `/health` - Базова перевірка здоров'я
- `/health/ready` - Валідує зв'язок з основним сервером

### Безпека
- Використовувати HTTPS в production
- Service токени - JWT (безпечно)
- Валідація публічного ключа
- CORS налаштований (налаштувати для production)

### Масштабованість
- Безстатевий дизайн (може масштабуватися горизонтально)
- Зберігання токена в пам'яті (розглянути Redis для мульти-інстанс)
- Кешування публічного ключа (зменшує навантаження на основний сервер)

## Загальні патерни

### Додавання нового захищеного endpoint
1. Додати метод до відповідного контролера
2. Використати декоратор `@UseGuards(JwtAuthGuard)`
3. Використати `MainServerClientService` для запитів до основного сервера
4. Повертати консистентний формат відповіді

### Додавання нового endpoint основного сервера
1. Додати метод до `MainServerClientService`
2. Використати приватний метод `request<T>()`
3. Обробляти помилки консистентно
4. Повертати формат `MainServerResponse<T>`

### Обробка помилок
- Використовувати NestJS `HttpException` для стандартних помилок
- Глобальний фільтр обробляє 401 (редирект на SSO)
- Логувати помилки з контекстом
- Повертати консистентний формат помилки

## Точки інтеграції

### З основною CRM системою
- SSO потік автентифікації
- Доступ до профілю користувача
- Операції з балансом
- Аналітичні події
- Отримання публічного ключа

### З фронтендом
- SSO редіректи (URL фронтендів)
- Відповіді помилок (для API викликів)
- Управління service токенами (клієнтська сторона)

## Примітки для створення нового екземпляру

1. **Змінні оточення:**
   - Скопіювати `.env.example` в `.env`
   - Встановити `MAIN_SERVER_URL` (API бекенду основної CRM)
   - Встановити `MAIN_FRONTEND_URL` (URL фронтенду основної CRM)
   - Встановити `SERVICE_NAME` (унікальний ідентифікатор)

2. **Service токен:**
   - Отримується через SSO потік
   - Зберігається в пам'яті
   - Валідується при кожному запиті
   - Термін дії 90 днів

3. **Публічний ключ:**
   - Отримується з основного сервера при старті
   - Кешується на 1 годину
   - Необхідний для валідації JWT

4. **Комунікація з основним сервером:**
   - Всі запити використовують `MainServerClientService`
   - Service токен автоматично додається
   - Обробка помилок включена

5. **SSO потік:**
   - Редіректи користувачів йдуть на URL **фронтендів**
   - Комунікація бекендів використовує service токени
   - Обмін коду є бекенд-до-бекенд

6. **Конфігурація:**
   - База даних не потрібна
   - Конфігурація через змінні оточення
   - Безстатевий дизайн

## Настанови для адаптації

### При створенні нового зовнішнього сервісу

1. **Скопіювати структуру:**
   - Скопіювати всю структуру проекту
   - Оновити ім'я та опис в `package.json`
   - Оновити ім'я сервісу в env змінних

2. **Оновити конфігурацію:**
   - Встановити новий `SERVICE_NAME`
   - Оновити `MAIN_SERVER_URL` якщо потрібно
   - Оновити `MAIN_FRONTEND_URL` якщо потрібно

3. **Налаштувати контролери:**
   - Модифікувати `OperationsController` для специфічних операцій
   - Додати нові контролери якщо потрібно
   - Зберегти патерн автентифікації

4. **Додати бізнес-логіку:**
   - Розширити `MainServerClientService` для нових endpoints
   - Додати нові сервіси якщо потрібно
   - Дотримуватися існуючих патернів

5. **Оновити документацію:**
   - Оновити `README.md`
   - Оновити Swagger документацію
   - Задокументувати нові endpoints

### При адаптації існуючого сервісу

1. **Зберегти основну структуру:**
   - Підтримувати потік автентифікації
   - Зберегти логіку SSO редіректу (URL фронтендів)
   - Зберегти обробку помилок

2. **Розширити функціональність:**
   - Додати нові endpoints до контролерів
   - Додати нові методи до сервісів
   - Додати нові DTOs якщо потрібно

3. **Підтримувати консистентність:**
   - Використовувати той самий формат відповіді
   - Дотримуватися тієї ж обробки помилок
   - Використовувати той самий патерн автентифікації

---

**Створено:** 2024  
**Останнє оновлення:** 2024  
**Версія:** 1.0
